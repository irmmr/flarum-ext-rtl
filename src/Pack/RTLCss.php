<?php
/**
 * RTLCss
 *
 * @package   MoodleHQ\RTLCSS
 * @copyright 2016 Frédéric Massart - FMCorz.net
 * @license   https://opensource.org/licenses/MIT MIT
 */

namespace Irmmr\FlarumRtlSupport\Pack;

use Sabberworm\CSS\CSSList\CSSList;
use Sabberworm\CSS\CSSList\Document;
//use Sabberworm\CSS\OutputFormat;
use Sabberworm\CSS\Parser;
use Sabberworm\CSS\Parsing\SourceException;
use Sabberworm\CSS\Rule\Rule;
use Sabberworm\CSS\RuleSet\RuleSet;
//use Sabberworm\CSS\Settings;
use Sabberworm\CSS\Value\CSSFunction;
//use Sabberworm\CSS\Value\CSSString;
//use Sabberworm\CSS\Value\PrimitiveValue;
use Sabberworm\CSS\Value\RuleValueList;
use Sabberworm\CSS\Value\Size;
use Sabberworm\CSS\Value\ValueList;

/**
 * RTLCss Class.
 *
 * This PHP class was written by `Frédéric Massart` and a composer package has also been created for it.
 * However, due to a lack of maintenance or other issues, it needs some changes and improvements.
 * All comments have been generated by AI, and some parts of the code have been improved for better usability.
 *
 * Irmmr <irmmr.ir@gmail.com>
 */
class RTLCss
{
    /**
     * Parsed tree of css
     * @var  Document
     */
    protected Document $tree;

    /**
     * @var array
     */
    protected array $shouldAddCss = [];

    /**
     * @var bool
     */
    protected bool $shouldIgnore = false;

    /**
     * @var bool
     */
    protected bool $shouldRemove = false;

    /**
     * The function is a PHP constructor that initializes a property with a Document object.
     *
     * @param Document  $tree    tree The `tree` parameter in the constructor is of type `Document`.
     */
    public function __construct(Document $tree)
    {
        $this->tree = $tree;
    }

    /**
     * The `compare` function compares two values while optionally ignoring case sensitivity in PHP.
     *
     * @param string    $what     what The `` parameter is the first value that you want to compare.
     * @param string    $to       to The `` parameter in the `compare` function represents the value that you want to
     * compare against.
     * @param bool      $ignoreCase  ignoreCase The `ignoreCase` parameter is a boolean flag that determines whether the
     * comparison should be case-insensitive. If `ignoreCase` is `true`, the comparison will be done in a
     * case-insensitive manner by converting both `` and `` to lowercase before comparing them. If
     * `ignore
     *
     * @return bool  `compare` function returns `true` if the values of `` and `` are equal (ignoring
     * case if `` is true), and `false` otherwise.
     */
    protected function compare(string $what, string $to, bool $ignoreCase): bool
    {
        if ($ignoreCase) {
            return strtolower($what) === strtolower($to);
        }

        return $what === $to;
    }


    /**
     * The `complement` function in PHP complements the input value by either subtracting it from 100 or
     * subtracting its arguments from 100%.
     *
     * @param Size|CSSFunction $value value The `complement` function takes a parameter named ``. This function checks if the
     * `` is an instance of the `Size` class or the `CSSFunction` class.
     */
    protected function complement($value): void
    {
        if ($value instanceof Size) {
            $value->setSize(100 - $value->getSize());
        } else if ($value instanceof CSSFunction) {
            $arguments = implode($value->getListSeparator(), $value->getArguments());
            $arguments = "100% - ($arguments)";
            $value->setListComponents([$arguments]);
        }
    }


    /**
     * The flip function processes a block within a document and returns the modified document.
     *
     * @return Document The `flip()` function is returning the `Document` object stored in the ``
     * property after processing it with the `processBlock()` method.
     * @throws SourceException
     */
    public function flip(): Document
    {
        $this->processBlock($this->tree);

        return $this->tree;
    }

    /**
     * The `negate` function in PHP recursively negates the values in a `ValueList` object or sets the size
     * to its negative value in a `Size` object.
     *
     * @param ValueList|Size $value value The `negate` function takes either a `ValueList` object or a `Size` object as
     * its parameter. If the parameter is a `ValueList`, it recursively negates each component of the list.
     * If the parameter is a `Size`, it checks if the size is not zero and
     */
    protected function negate($value): void
    {
        if ($value instanceof ValueList) {
            foreach ($value->getListComponents() as $part) {
                $this->negate($part);
            }
        } else if ($value instanceof Size) {
            if ($value->getSize() != 0) {
                $value->setSize(-$value->getSize());
            }
        }
    }

    /**
     * The function `parseComments` processes an array of comments to determine specific actions based on
     * certain rules defined within the comments.
     *
     * @param array $comments comments The `parseComments` function takes an array of comments as input. It then
     * iterates over each comment in the array and checks for specific patterns within the comment content
     * using regular expressions.
     */
    protected function parseComments(array $comments): void
    {
        $startRule = '^(\s|\*)*!?rtl:';

        foreach ($comments as $comment) {
            $content = $comment->getComment();

            if (preg_match('/' . $startRule . 'ignore/', $content)) {
                $this->shouldIgnore = 1;
            } else if (preg_match('/' . $startRule . 'begin:ignore/', $content)) {
                $this->shouldIgnore = true;
            } else if (preg_match('/' . $startRule . 'end:ignore/', $content)) {
                $this->shouldIgnore = false;
            } else if (preg_match('/' . $startRule . 'remove/', $content)) {
                $this->shouldRemove = 1;
            } else if (preg_match('/' . $startRule . 'begin:remove/', $content)) {
                $this->shouldRemove = true;
            } else if (preg_match('/' . $startRule . 'end:remove/', $content)) {
                $this->shouldRemove = false;
            } else if (preg_match('/' . $startRule . 'raw:/', $content)) {
                $this->shouldAddCss[] = preg_replace('/' . $startRule . 'raw:/', '', $content);
            }
        }
    }

    /**
     * The function `processBackground` processes background rules, handling multiple sets of properties
     * and values within each set.
     *
     * @param Rule $rule rule The `processBackground` method takes a `Rule` object as a parameter. This method
     * processes the background properties of the given rule. It first retrieves the value from the rule
     * and then checks if the value is a list with commas as separators. If it is, it splits the list into
     * individual components
     */
    protected function processBackground(Rule $rule): void
    {
        $value = $rule->getValue();

        // TODO Fix upstream library as it does not parse this well, commas don't take precedence.
        // There can be multiple sets of properties per rule.
        $hasItems = false;
        $items = [$value];

        if ($value instanceof RuleValueList && $value->getListSeparator() == ',') {
            $hasItems = true;
            $items = $value->getListComponents();
        }

        // Foreach set.
        foreach ($items as $itemKey => $item) {

            // There can be multiple values in the same set.
            $hasValues = false;
            $parts = [$item];

            if ($item instanceof RuleValueList) {
                $hasValues = true;
                $parts = $value->getListComponents();
            }

            $requiresPositionalArgument = false;
            $hasPositionalArgument = false;

            $key = null;

            foreach ($parts as $key => $part) {
                $part = $parts[$key];

                if (!is_object($part)) {
                    $flipped = $this->swapLeftRight($part);

                    // Positional arguments can have a size following.
                    $hasPositionalArgument = $parts[$key] != $flipped;
                    $requiresPositionalArgument = true;

                    $parts[$key] = $flipped;
                    continue;

                } else if ($part instanceof CSSFunction && strpos($part->getName(), 'gradient') !== false) {
                    // TODO Fix this.

                } else if ($part instanceof Size && ($part->getUnit() === '%' || !$part->getUnit())) {

                    // Is this a value we're interested in?
                    if (!$requiresPositionalArgument || $hasPositionalArgument) {
                        $this->complement($part);
                        $part->setUnit('%');
                        // We only need to change one value.
                        break;
                    }

                }

                $hasPositionalArgument = false;
            }

            if ($hasValues) {
                $item->setListComponents($parts);
            } else {
                $items[$itemKey] = $parts[$key];
            }
        }

        if ($hasItems) {
            $value->setListComponents($items);
        } else {
            $rule->setValue($items[0]);
        }
    }

    /**
     * The function `processBlock` iterates through a document's contents, parsing CSS comments, adding CSS
     * rules, and processing CSS blocks and rule sets.
     *
     * @param mixed $block block The `processBlock` function takes a `Document` object named `` as a
     * parameter. Within the function, it processes the contents of the block by iterating over each node
     * in the block's contents.
     * @throws SourceException
     */
    protected function processBlock($block): void
    {
        $contents = [];

        foreach ($block->getContents() as $node) {
            $this->parseComments($node->getComments());

            if ($toAdd = $this->shouldAddCss()) {
                foreach ($toAdd as $add) {
                    $parser = new Parser($add);
                    $contents[] = $parser->parse();
                }
            }

            if ($this->shouldRemoveNext()) {
                continue;
            } else if (!$this->shouldIgnoreNext()) {
                if ($node instanceof CSSList) {
                    $this->processBlock($node);
                }

                if ($node instanceof RuleSet) {
                    $this->processDeclaration($node);
                }
            }

            $contents[] = $node;
        }

        $block->setContents($contents);
    }

    /**
     * The function `processDeclaration` processes rules in a node, potentially adding or removing CSS
     * rules based on certain conditions.
     *
     * @param mixed $node node The `processDeclaration` function takes a parameter named ``, which is
     * expected to be of type `mixed`. This function processes the rules of the given node, adds new CSS
     * rules if necessary, and updates the rules of the node accordingly. The function iterates over the
     * rules of the node,
     * @throws SourceException
     */
    protected function processDeclaration($node): void
    {
        $rules = [];

        foreach ($node->getRules() as $key => $rule) {
            $this->parseComments($rule->getComments());

            if ($toAdd = $this->shouldAddCss()) {
                foreach ($toAdd as $add) {
                    $parser = new Parser('.wrapper{' . $add . '}');
                    $tree = $parser->parse();

                    $contents = $tree->getContents();
                    foreach ($contents[0]->getRules() as $newRule) {
                        $rules[] = $newRule;
                    }
                }
            }

            if ($this->shouldRemoveNext()) {
                continue;
            } else if (!$this->shouldIgnoreNext()) {
                $this->processRule($rule);
            }

            $rules[] = $rule;
        }

        $node->setRules($rules);
    }

    /**
     * The function `processRule` in PHP processes different CSS properties and values, making various
     * modifications based on specific conditions and patterns.
     *
     * @param mixed $rule rule The `processRule` function takes a parameter named ``, which is expected to
     * be an object with properties `getRule()` and `getValue()`. The function then processes the rule
     * based on the value of the `property` obtained from `getRule()` and the `value` obtained from `
     */
    protected function processRule($rule): void
    {
        $property = $rule->getRule();
        $value = $rule->getValue();

        if (preg_match('/direction$/im', $property)) {
            $rule->setValue($this->swapLtrRtl($value));

        } else if (preg_match('/left/im', $property)) {
            $rule->setRule(str_replace('left', 'right', $property));

        } else if (preg_match('/right/im', $property)) {
            $rule->setRule(str_replace('right', 'left', $property));

        } else if (preg_match('/transition(-property)?$/i', $property)) {
            $rule->setValue($this->swapLeftRight($value));

        } else if (preg_match('/float|clear|text-align/i', $property)) {
            $rule->setValue($this->swapLeftRight($value));

        } else if (preg_match('/^(margin|padding|border-(color|style|width))$/i', $property)) {
            if ($value instanceof RuleValueList) {
                $values = $value->getListComponents();
                $count = count($values);

                if ($count == 4) {
                    $right = $values[3];
                    $values[3] = $values[1];
                    $values[1] = $right;
                }

                $value->setListComponents($values);
            }
        } else if (preg_match('/border-radius/i', $property)) {
            if ($value instanceof RuleValueList) {
                // Border radius can contain two lists separated by a slash.
                $groups = $value->getListComponents();

                if ($value->getListSeparator() !== '/') {
                    $groups = [$value];
                }

                foreach ($groups as $group) {
                    $values = $group->getListComponents();
                    switch (count($values)) {
                        case 2:
                            $group->setListComponents(array_reverse($values));
                            break;
                        case 3:
                            $group->setListComponents([$values[1], $values[0], $values[1], $values[2]]);
                            break;
                        case 4:
                            $group->setListComponents([$values[1], $values[0], $values[3], $values[2]]);
                            break;
                    }
                }
            }

        } else if (preg_match('/shadow/i', $property)) {
            // TODO Fix upstream, each shadow should be in a RuleValueList.
            if ($value instanceof RuleValueList) {
                // negate($value->getListComponents()[0]);
            }
        } else if (preg_match('/transform-origin/i', $property)) {
            $this->processTransformOrigin($rule);
        } else if (preg_match('/^(?!text\-).*?transform$/i', $property)) {
            // TODO Parse function parameters first.
        } else if (preg_match('/background(-position(-x)?|-image)?$/i', $property)) {
            $this->processBackground($rule);
        } else if (preg_match('/cursor/i', $property)) {
            $hasList = false;

            $parts = [$value];

            if ($value instanceof RuleValueList) {
                $hasList = true;
                $parts = $value->getListComponents();
            }

            foreach ($parts as $key => $part) {
                if (!is_object($part)) {
                    $parts[$key] = preg_replace_callback('/\b(ne|nw|se|sw|nesw|nwse)-resize/', function($matches) {
                        return str_replace($matches[1], str_replace(['e', 'w', '*'], ['*', 'e', 'w'], $matches[1]), $matches[0]);
                    }, $part);
                }
            }

            if ($hasList) {
                $value->setListComponents($parts);
            } else {
                $rule->setValue($parts[0]);
            }
        }
    }

    /**
     * The function `processTransformOrigin` in PHP processes the transform origin property value by
     * handling left/right keywords and flipping the value if necessary.
     *
     * @param Rule $rule rule The `processTransformOrigin` function takes a `Rule` object as a parameter. This
     * function processes the `transform-origin` CSS property value within the given `Rule`.
     */
    protected function processTransformOrigin(Rule $rule): void
    {
        $value = $rule->getValue();
        $foundLeftOrRight = false;

        // Search for left or right.
        $parts = [$value];
        if ($value instanceof RuleValueList) {
            $parts = $value->getListComponents();
            $isInList = true;
        }

        foreach ($parts as $key => $part) {
            if (!is_object($part) && preg_match('/left|right/i', $part)) {
                $foundLeftOrRight = true;
                $parts[$key] = $this->swapLeftRight($part);
            }
        }

        if ($foundLeftOrRight) {
            // We need to reconstruct the value because left/right are not represented by an object.
            $list = new RuleValueList(' ');
            $list->setListComponents($parts);
            $rule->setValue($list);
        } else {
            $value = $parts[0];

            // The first value may be referencing top or bottom (y instead of x).
            if (!is_object($value) && preg_match('/top|bottom/i', $value)) {
                $value = $parts[1];
            }

            // Flip the value.
            if ($value instanceof Size) {
                if ($value->getSize() == 0) {
                    $value->setSize(100);
                    $value->setUnit('%');

                } else if ($value->getUnit() === '%') {
                    $this->complement($value);
                }
            } else if ($value instanceof CSSFunction && strpos($value->getName(), 'calc') !== false) {
                // TODO Fix upstream calc parsing.
                $this->complement($value);
            }
        }
    }

    /**
     * The function `shouldAddCss` returns and clears a CSS array if it is not empty, otherwise it returns
     * an empty array.
     *
     * @return array An array of CSS files that need to be added. If there are no CSS files to add, an empty
     * array is returned.
     */
    protected function shouldAddCss(): array
    {
        if (!empty($this->shouldAddCss)) {
            $css = $this->shouldAddCss;
            $this->shouldAddCss = [];

            return $css;
        }

        return [];
    }

    /**
     * The function `shouldIgnoreNext` checks if a certain condition is met and returns a boolean value
     * accordingly.
     *
     * @return bool The function `shouldIgnoreNext()` returns a boolean value, either `true` or `false`.
     */
    protected function shouldIgnoreNext(): bool
    {
        if ($this->shouldIgnore) {
            if (is_int($this->shouldIgnore)) {
                $this->shouldIgnore--;
            }

            return true;
        }

        return false;
    }

    /**
     * The function `shouldRemoveNext` checks if a certain condition is met and returns a boolean value
     * accordingly.
     *
     * @return bool The `shouldRemoveNext()` function returns a boolean value - `true` if the conditions
     * are met for removing the next item, and `false` otherwise.
     */
    protected function shouldRemoveNext(): bool
    {
        if ($this->shouldRemove) {
            if (is_int($this->shouldRemove)) {
                $this->shouldRemove--;
            }

            return true;
        }

        return false;
    }

    /**
     * The function `swap` in PHP swaps occurrences of two specified strings in a given string based on
     * certain options.
     *
     * @param string $value value The `value` parameter in the `swap` function represents the string in which you
     * want to swap occurrences of strings `` and `` based on the specified options.
     * @param string $a a The `swap` function you provided is a protected method that takes in a string
     * ``, two strings `` and `` to swap, and an optional array `` with default values.
     * The function uses regular expressions to find occurrences of either `` or `` in
     * @param string $b b The `swap` function takes in a string ``, and two strings `` and `` that
     * you want to swap in the `` string. Additionally, it accepts an optional array `` with
     * default values set for `'scope'` and `'ignoreCase'`.
     * @param array $options options The `swap` function you provided takes in four parameters:
     *
     * @return string The `swap` function returns a string after performing a replacement operation using
     * regular expressions.
     */
    protected function swap(string $value, string $a, string $b, array $options = ['scope' => '*', 'ignoreCase' => true]): string
    {
        $expr = preg_quote($a) . '|' . preg_quote($b);

        if (!empty($options['greedy'])) {
            $expr = '\\b(' . $expr . ')\\b';
        }

        $flags = !empty($options['ignoreCase']) ? 'im' : 'm';
        $expr  = "/$expr/$flags";

        return preg_replace_callback($expr, function($matches) use ($a, $b, $options) {
            return $this->compare($matches[0], $a, !empty($options['ignoreCase'])) ? $b : $a;
        }, $value);
    }

    /**
     * The function `swapLeftRight` swaps the positions of the words 'left' and 'right' in a given string.
     *
     * @param string $value value The `swapLeftRight` function takes a string input `` and swaps the
     * occurrences of the word 'left' with 'right' in the string.
     *
     * @return string The `swapLeftRight` function is returning the result of calling the `swap` method
     * with the parameters `'left'` and `'right'` on the input string ``.
     */
    protected function swapLeftRight(string $value): string
    {
        return $this->swap($value, 'left', 'right');
    }

    /**
     * The function `swapLtrRtl` swaps the direction of text from left-to-right to right-to-left in a given
     * string.
     *
     * @param string $value value The `value` parameter is a string that represents the text that you want to swap
     * from left-to-right (ltr) to right-to-left (rtl) or vice versa.
     *
     * @return string The `swapLtrRtl` function is returning the result of calling the `swap` method with
     * the input string `` and the parameters 'ltr' and 'rtl'.
     */
    protected function swapLtrRtl(string $value): string
    {
        return $this->swap($value, 'ltr', 'rtl');
    }
}